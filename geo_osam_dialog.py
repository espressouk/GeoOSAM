# Show success message with crop mode info
from qgis.PyQt.QtCore import QVariant, Qt
from qgis.core import (
    QgsProject,
    QgsRasterLayer,
    QgsRectangle,
    QgsWkbTypes,
    QgsPointXY,
    QgsVectorLayer,
    QgsFeature,
    QgsGeometry,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFillSymbol,
    QgsMarkerSymbol,
    QgsField,
    QgsMessageLog,
    Qgis,
    QgsVectorFileWriter
)
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand, QgsMapTool
from qgis.PyQt import QtWidgets, uic, QtCore, QtGui
import os
import pathlib
import datetime
import shutil
import io

"""
/***************************************************************************
 GeoOSAM Control Panel
                                 A QGIS plugin
 generate poly using SAM with enhanced UX - Control Panel Version
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Ofer Butbega
        email                : bkst.dev@gmail.com
 ***************************************************************************/
"""

# ----------------------------------------------------------------------
# Enhanced map-tools with improved visual feedback
# ----------------------------------------------------------------------


class EnhancedPointClickTool(QgsMapTool):
    def __init__(self, canvas, cb):
        super().__init__(canvas)
        self.canvas = canvas
        self.cb = cb
        self.setCursor(QtCore.Qt.CrossCursor)

        # Visual feedback for point - temporary marker that shows where user clicked
        self.point_rubber = QgsRubberBand(canvas, QgsWkbTypes.PointGeometry)
        self.point_rubber.setColor(QtCore.Qt.red)
        self.point_rubber.setIcon(QgsRubberBand.ICON_CIRCLE)
        self.point_rubber.setIconSize(12)
        self.point_rubber.setWidth(4)

        # Store the clicked point for display
        self.last_click_point = None

    def canvasReleaseEvent(self, e):
        # Get map coordinates from click position
        map_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())

        # Store for visual feedback
        self.last_click_point = map_point

        # Show visual feedback immediately at click location
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.point_rubber.addPoint(map_point, True)
        self.canvas.refresh()

        # Call callback with point (this triggers segmentation)
        self.cb(map_point)

    def deactivate(self):
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.last_click_point = None
        super().deactivate()

    def clear_feedback(self):
        """Clear the point visual feedback after polygon is generated"""
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.canvas.refresh()
        self.last_click_point = None


class EnhancedBBoxClickTool(QgsMapTool):
    def __init__(self, canvas, cb):
        super().__init__(canvas)
        self.canvas = canvas
        self.cb = cb
        self.setCursor(QtCore.Qt.CrossCursor)

        self.start_point = None
        self.is_dragging = False

        # Visual feedback for bbox - live preview
        self.bbox_rubber = QgsRubberBand(canvas, QgsWkbTypes.PolygonGeometry)
        self.bbox_rubber.setColor(QtCore.Qt.blue)
        self.bbox_rubber.setFillColor(QtGui.QColor(0, 0, 255, 60))
        self.bbox_rubber.setWidth(2)

    def canvasPressEvent(self, e):
        self.start_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
        self.is_dragging = True
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)

    def canvasMoveEvent(self, e):
        if self.is_dragging and self.start_point:
            current_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
            rect = QgsRectangle(self.start_point, current_point)
            self.bbox_rubber.setToGeometry(QgsGeometry.fromRect(rect), None)
            self.canvas.refresh()

    def canvasReleaseEvent(self, e):
        if self.is_dragging and self.start_point:
            end_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
            rect = QgsRectangle(self.start_point, end_point)

            # Ensure minimum size (10 map units)
            if rect.width() > 10 and rect.height() > 10:
                self.cb(rect)
            else:
                # Reset if too small
                self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
                self.canvas.refresh()

        self.is_dragging = False
        self.start_point = None

    def deactivate(self):
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
        self.is_dragging = False
        self.start_point = None
        super().deactivate()

    def clear_feedback(self):
        """Clear the bbox visual feedback after polygon is generated"""
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
        self.canvas.refresh()


# ----------------------------------------------------------------------
# GeoOSAM Control Panel - Dockable Widget
# ----------------------------------------------------------------------

class GeoOSAMControlPanel(QtWidgets.QDockWidget):
    """Dockable control panel for GeoOSAM segmentation"""

    # Default class definitions with distinct, vibrant colors
    DEFAULT_CLASSES = {
        # Crimson Red
        'Buildings': {'color': '220,20,60', 'description': 'Residential and commercial buildings'},
        # Dim Gray
        'Roads': {'color': '105,105,105', 'description': 'Streets, highways, and pathways'},
        # Forest Green
        'Vegetation': {'color': '34,139,34', 'description': 'Trees, grass, and vegetation'},
        # Dodger Blue
        'Water': {'color': '30,144,255', 'description': 'Rivers, lakes, and water bodies'},
        # Gold
        'Agriculture': {'color': '255,215,0', 'description': 'Farmland and crops'},
        # Dark Orange
        'Parking': {'color': '255,140,0', 'description': 'Parking lots and areas'},
        # Blue Violet
        'Industrial': {'color': '138,43,226', 'description': 'Industrial buildings and areas'},
        # Deep Pink
        'Residential': {'color': '255,20,147', 'description': 'Residential areas'},
        # Deep Sky Blue
        'Commercial': {'color': '0,191,255', 'description': 'Commercial areas'},
        # Dark Violet
        'Other': {'color': '148,0,211', 'description': 'Unclassified objects'}
    }

    # Additional color palette for new classes
    EXTRA_COLORS = [
        '255,69,0',    # Red Orange
        '50,205,50',   # Lime Green
        '255,20,147',  # Deep Pink
        '0,206,209',   # Dark Turquoise
        '255,165,0',   # Orange
        '186,85,211',  # Medium Orchid
        '0,128,128',   # Teal
        '255,192,203',  # Pink
        '165,42,42',   # Brown
        '0,250,154',   # Medium Spring Green
        '255,0,255',   # Magenta
        '127,255,212',  # Aquamarine
        '255,99,71',   # Tomato
        '72,61,139',   # Dark Slate Blue
        '218,165,32'   # Goldenrod
    ]

    API_BASE = "http://[::]:5000"

    def __init__(self, iface, parent=None):
        super().__init__("GeoOSAM Control Panel", parent)
        self.iface = iface
        self.canvas = iface.mapCanvas()

        # Make dockable
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.setFeatures(QtWidgets.QDockWidget.DockWidgetMovable |
                         QtWidgets.QDockWidget.DockWidgetFloatable)

        # State variables
        self.point = None
        self.bbox = None
        self.current_mode = None
        self.result_layers = {}
        self.segment_counts = {}
        self.mask_save_dir = None
        self.shapefile_save_dir = None
        self.current_class = None
        self.classes = self.DEFAULT_CLASSES.copy()

        # Initialize directories
        self._init_save_directories()

        # Enhanced map tools
        self.pointTool = EnhancedPointClickTool(self.canvas, self._point_done)
        self.bboxTool = EnhancedBBoxClickTool(self.canvas, self._bbox_done)

        # Store original map tool
        self.original_map_tool = None

        # Setup UI
        self._setup_ui()

    def _init_save_directories(self):
        """Initialize directories for saving masks and shapefiles"""
        self.mask_save_dir = pathlib.Path.home() / "GeoOSAM_masks"
        self.mask_save_dir.mkdir(exist_ok=True)

        self.shapefile_save_dir = pathlib.Path.home() / "GeoOSAM_shapefiles"
        self.shapefile_save_dir.mkdir(exist_ok=True)

        QgsMessageLog.logMessage(
            f"Save directories: masks={self.mask_save_dir}, shapefiles={self.shapefile_save_dir}",
            "GeoOSAM", Qgis.Info)

    def _setup_ui(self):
        """Setup the control panel UI"""
        # Main widget and layout
        main_widget = QtWidgets.QWidget()
        self.setWidget(main_widget)

        layout = QtWidgets.QVBoxLayout(main_widget)
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)

        # Title
        title = QtWidgets.QLabel("üõ∞Ô∏è GeoOSAM Control Panel")
        title.setStyleSheet(
            "font-size: 14px; font-weight: bold; color: #2E86AB; padding: 5px;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)

        # Separator
        separator1 = QtWidgets.QFrame()
        separator1.setFrameShape(QtWidgets.QFrame.HLine)
        separator1.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator1)

        # Class Selection Section
        self._setup_class_section(layout)

        # Separator
        separator2 = QtWidgets.QFrame()
        separator2.setFrameShape(QtWidgets.QFrame.HLine)
        separator2.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator2)

        # Mode Selection Section
        self._setup_mode_section(layout)

        # Separator
        separator3 = QtWidgets.QFrame()
        separator3.setFrameShape(QtWidgets.QFrame.HLine)
        separator3.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator3)

        # Status Section
        self._setup_status_section(layout)

        # Separator
        separator4 = QtWidgets.QFrame()
        separator4.setFrameShape(QtWidgets.QFrame.HLine)
        separator4.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator4)

        # Control Buttons Section
        self._setup_control_section(layout)

        # Stretch to push everything to top
        layout.addStretch()

        # Set fixed width for panel
        self.setMinimumWidth(280)
        self.setMaximumWidth(350)

    def _setup_class_section(self, layout):
        """Setup class selection section"""
        # Class selection header
        class_header = QtWidgets.QLabel("üìã Class Selection")
        class_header.setStyleSheet(
            "font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(class_header)

        # Class combo box
        self.classComboBox = QtWidgets.QComboBox()
        self.classComboBox.addItem("-- Select Class --", None)

        for class_name, class_info in self.classes.items():
            self.classComboBox.addItem(f"{class_name}", class_name)

        self.classComboBox.currentTextChanged.connect(self._on_class_changed)
        self.classComboBox.setStyleSheet("padding: 4px; font-size: 11px;")
        layout.addWidget(self.classComboBox)

        # Current class display
        self.currentClassLabel = QtWidgets.QLabel("Current Class: None")
        self.currentClassLabel.setStyleSheet(
            "font-weight: bold; padding: 8px; border: 2px solid gray; "
            "background-color: rgba(200,200,200,50); border-radius: 4px; font-size: 11px;")
        self.currentClassLabel.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.currentClassLabel)

        # Class management buttons
        class_btn_layout = QtWidgets.QHBoxLayout()

        self.addClassBtn = QtWidgets.QPushButton("‚ûï Add")
        self.addClassBtn.clicked.connect(self._add_new_class)
        self.addClassBtn.setStyleSheet("font-size: 10px; padding: 4px;")
        class_btn_layout.addWidget(self.addClassBtn)

        self.editClassBtn = QtWidgets.QPushButton("‚úèÔ∏è Edit")
        self.editClassBtn.clicked.connect(self._edit_classes)
        self.editClassBtn.setStyleSheet("font-size: 10px; padding: 4px;")
        class_btn_layout.addWidget(self.editClassBtn)

        layout.addLayout(class_btn_layout)

    def _setup_mode_section(self, layout):
        """Setup mode selection section"""
        # Mode selection header
        mode_header = QtWidgets.QLabel("üéØ Segmentation Mode")
        mode_header.setStyleSheet(
            "font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(mode_header)

        # Mode buttons
        mode_layout = QtWidgets.QVBoxLayout()

        self.pointModeBtn = QtWidgets.QPushButton("üéØ Point Mode")
        self.pointModeBtn.clicked.connect(self._activate_point_tool)
        self.pointModeBtn.setStyleSheet(
            "padding: 8px; font-size: 12px; font-weight: bold; "
            "background-color: #4CAF50; color: white; border-radius: 4px;")
        mode_layout.addWidget(self.pointModeBtn)

        self.bboxModeBtn = QtWidgets.QPushButton("üì¶ BBox Mode")
        self.bboxModeBtn.clicked.connect(self._activate_bbox_tool)
        self.bboxModeBtn.setStyleSheet(
            "padding: 8px; font-size: 12px; font-weight: bold; "
            "background-color: #2196F3; color: white; border-radius: 4px;")
        mode_layout.addWidget(self.bboxModeBtn)

        layout.addLayout(mode_layout)

        # Current mode indicator
        self.currentModeLabel = QtWidgets.QLabel("Mode: None")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #f0f0f0; border-radius: 3px; font-size: 10px;")
        self.currentModeLabel.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.currentModeLabel)

    def _setup_status_section(self, layout):
        """Setup status display section"""
        # Status header
        status_header = QtWidgets.QLabel("üìä Status")
        status_header.setStyleSheet(
            "font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(status_header)

        # Status display
        self.statusLabel = QtWidgets.QLabel("Ready to segment")
        self.statusLabel.setStyleSheet(
            "padding: 6px; background-color: #e8f5e8; border-left: 4px solid #4CAF50; "
            "font-size: 10px; border-radius: 3px;")
        self.statusLabel.setWordWrap(True)
        layout.addWidget(self.statusLabel)

        # Statistics
        self.statsLabel = QtWidgets.QLabel("Total Segments: 0")
        self.statsLabel.setStyleSheet(
            "font-size: 10px; color: #666; padding: 2px;")
        layout.addWidget(self.statsLabel)

    def _setup_control_section(self, layout):
        """Setup control buttons section"""
        # Control header
        control_header = QtWidgets.QLabel("‚öôÔ∏è Controls")
        control_header.setStyleSheet(
            "font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(control_header)

        # Control buttons
        control_layout = QtWidgets.QVBoxLayout()

        self.clearBtn = QtWidgets.QPushButton("üîÑ Clear Selection")
        self.clearBtn.clicked.connect(self._clear_current_selection)
        self.clearBtn.setStyleSheet(
            "padding: 6px; font-size: 10px; background-color: #FFC107; border-radius: 3px;")
        control_layout.addWidget(self.clearBtn)

        self.newShapeBtn = QtWidgets.QPushButton("üÜï New Shape")
        self.newShapeBtn.clicked.connect(self._start_new_shape)
        self.newShapeBtn.setStyleSheet(
            "padding: 6px; font-size: 10px; background-color: #FF9800; border-radius: 3px;")
        control_layout.addWidget(self.newShapeBtn)

        self.exportBtn = QtWidgets.QPushButton("üíæ Export All")
        self.exportBtn.clicked.connect(self._export_all_classes)
        self.exportBtn.setStyleSheet(
            "padding: 6px; font-size: 10px; background-color: #9C27B0; color: white; border-radius: 3px;")
        control_layout.addWidget(self.exportBtn)

        layout.addLayout(control_layout)

    def _update_status(self, message, status_type="info"):
        """Update status display"""
        colors = {
            "info": "#e8f5e8; border-left: 4px solid #4CAF50",
            "warning": "#fff3cd; border-left: 4px solid #FFC107",
            "error": "#f8d7da; border-left: 4px solid #DC3545",
            "processing": "#d4edda; border-left: 4px solid #17a2b8"
        }

        color_style = colors.get(status_type, colors["info"])
        self.statusLabel.setText(message)
        self.statusLabel.setStyleSheet(
            f"padding: 6px; background-color: {color_style}; "
            f"font-size: 10px; border-radius: 3px;")

    def _update_stats(self):
        """Update statistics display"""
        total_segments = sum(layer.featureCount()
                             for layer in self.result_layers.values() if layer)
        total_classes = len(
            [l for l in self.result_layers.values() if l and l.featureCount() > 0])

        self.statsLabel.setText(
            f"Total Segments: {total_segments} | Classes: {total_classes}")

    def _on_class_changed(self):
        """Handle class selection change"""
        selected_data = self.classComboBox.currentData()
        if selected_data:
            self.current_class = selected_data
            class_info = self.classes[selected_data]
            self.currentClassLabel.setText(f"Current: {selected_data}")

            # Update label color to match class color
            color = class_info['color']
            try:
                r, g, b = [int(c.strip()) for c in color.split(',')]
                self.currentClassLabel.setStyleSheet(
                    f"font-weight: bold; padding: 8px; margin: 2px; "
                    f"border: 3px solid rgb({r},{g},{b}); "
                    f"background-color: rgba({r},{g},{b}, 30); "
                    f"color: rgb({max(0, r-50)},{max(0, g-50)},{max(0, b-50)}); "
                    f"border-radius: 4px; font-size: 11px;")
            except:
                self.currentClassLabel.setStyleSheet(
                    f"font-weight: bold; padding: 8px; border: 2px solid rgb({color}); "
                    f"background-color: rgba({color}, 50); font-size: 11px;")
        else:
            self.current_class = None
            self.currentClassLabel.setText("Current: None")
            self.currentClassLabel.setStyleSheet(
                "font-weight: bold; padding: 8px; border: 2px solid gray; "
                "background-color: rgba(200,200,200,50); border-radius: 4px; font-size: 11px;")

    def _add_new_class(self):
        """Add a new class with automatic color assignment"""
        class_name, ok = QtWidgets.QInputDialog.getText(
            self, 'Add Class', 'Enter class name:')
        if ok and class_name and class_name not in self.classes:
            # Auto-assign next available color
            used_colors = [info['color'] for info in self.classes.values()]
            available_colors = [
                c for c in self.EXTRA_COLORS if c not in used_colors]

            if available_colors:
                color = available_colors[0]
            else:
                import random
                color = f"{random.randint(100,255)},{random.randint(100,255)},{random.randint(100,255)}"

            description = f'Custom class: {class_name}'

            self.classes[class_name] = {
                'color': color, 'description': description}
            self.classComboBox.addItem(class_name, class_name)
            self._update_status(
                f"Added class: {class_name} (RGB:{color})", "info")

    def _edit_classes(self):
        """Edit existing classes"""
        class_list = list(self.classes.keys())
        if not class_list:
            self._update_status("No classes to edit", "warning")
            return

        class_name, ok = QtWidgets.QInputDialog.getItem(
            self, 'Edit Classes', 'Select class to edit:', class_list, 0, False)

        if ok and class_name:
            current_info = self.classes[class_name]
            new_name, ok2 = QtWidgets.QInputDialog.getText(
                self, 'Edit Class Name', f'Edit name for {class_name}:', text=class_name)

            if ok2 and new_name:
                current_color = current_info['color']
                new_color, ok3 = QtWidgets.QInputDialog.getText(
                    self, 'Edit Color', f'Edit color for {new_name} (R,G,B):', text=current_color)

                if ok3 and new_color:
                    try:
                        parts = [int(p.strip()) for p in new_color.split(',')]
                        if len(parts) == 3 and all(0 <= p <= 255 for p in parts):
                            if new_name != class_name:
                                del self.classes[class_name]

                            self.classes[new_name] = {
                                'color': new_color,
                                'description': current_info.get('description', f'Class: {new_name}')
                            }
                            self._refresh_class_combo()
                            self._update_status(
                                f"Updated {new_name} with RGB({new_color})", "info")
                        else:
                            self._update_status(
                                "Invalid color format! Use R,G,B (0-255)", "error")
                    except ValueError:
                        self._update_status(
                            "Invalid color format! Use R,G,B (0-255)", "error")

    def _refresh_class_combo(self):
        """Refresh the class combo box"""
        current_class = self.current_class
        self.classComboBox.clear()
        self.classComboBox.addItem("-- Select Class --", None)

        for class_name, class_info in self.classes.items():
            self.classComboBox.addItem(class_name, class_name)

        if current_class and current_class in self.classes:
            index = self.classComboBox.findData(current_class)
            if index >= 0:
                self.classComboBox.setCurrentIndex(index)

    def _validate_class_selection(self):
        """Validate that a class is selected"""
        if not self.current_class:
            self._update_status("Please select a class first!", "warning")
            return False
        return True

    def _activate_point_tool(self):
        """Activate point segmentation tool"""
        if not self._validate_class_selection():
            return

        self.current_mode = 'point'
        self.original_map_tool = self.canvas.mapTool()

        self.currentModeLabel.setText("Mode: üéØ Point Active")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #4CAF50; color: white; border-radius: 3px; font-size: 10px;")

        self._update_status(
            f"Point mode active for [{self.current_class}]. Click on map to segment.", "processing")

        self.canvas.setMapTool(self.pointTool)

    def _activate_bbox_tool(self):
        """Activate bbox segmentation tool"""
        if not self._validate_class_selection():
            return

        self.current_mode = 'bbox'
        self.original_map_tool = self.canvas.mapTool()

        self.currentModeLabel.setText("Mode: üì¶ BBox Active")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #2196F3; color: white; border-radius: 3px; font-size: 10px;")

        self._update_status(
            f"BBox mode active for [{self.current_class}]. Click and drag to segment.", "processing")

        self.canvas.setMapTool(self.bboxTool)

    def _point_done(self, pt):
        """Handle point tool completion"""
        self.point = pt
        self.bbox = None

        self._update_status(
            f"Processing point at ({pt.x():.1f}, {pt.y():.1f})...", "processing")
        self._run_segmentation()

    def _bbox_done(self, rect):
        """Handle bbox tool completion"""
        self.bbox = rect
        self.point = None

        self._update_status(
            f"Processing bbox ({rect.width():.1f}√ó{rect.height():.1f})...", "processing")
        self._run_segmentation()

    def _clear_current_selection(self):
        """Clear current selection but keep tool active"""
        self.point = None
        self.bbox = None

        if hasattr(self.pointTool, 'clear_feedback'):
            self.pointTool.clear_feedback()
        if hasattr(self.bboxTool, 'clear_feedback'):
            self.bboxTool.clear_feedback()

        class_info = f"[{self.current_class}]" if self.current_class else ""
        if self.current_mode == 'point':
            self._update_status(
                f"Point mode {class_info}: Ready for next point", "info")
        elif self.current_mode == 'bbox':
            self._update_status(
                f"BBox mode {class_info}: Ready for next box", "info")
        else:
            self._update_status("Ready to segment", "info")

    def _start_new_shape(self):
        """Start completely new shape (remove existing layers)"""
        self.point = None
        self.bbox = None
        self.current_mode = None

        if hasattr(self.pointTool, 'clear_feedback'):
            self.pointTool.clear_feedback()
        if hasattr(self.bboxTool, 'clear_feedback'):
            self.bboxTool.clear_feedback()

        # Remove all result layers
        for class_name, layer in self.result_layers.items():
            if layer:
                QgsProject.instance().removeMapLayer(layer)

        self.result_layers = {}
        self.segment_counts = {}

        # Restore original map tool
        if self.original_map_tool:
            self.canvas.setMapTool(self.original_map_tool)

        self.currentModeLabel.setText("Mode: None")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #f0f0f0; border-radius: 3px; font-size: 10px;")

        self._update_status(
            "Ready for new shape. Select class and mode.", "info")
        self._update_stats()

    def _export_all_classes(self):
        """Export all class layers to shapefiles"""
        if not self.result_layers:
            self._update_status("No segments to export!", "warning")
            return

        exported_count = 0
        for class_name, layer in self.result_layers.items():
            if layer and layer.featureCount() > 0:
                if self._export_layer_to_shapefile(layer, class_name):
                    exported_count += 1

        if exported_count > 0:
            self._update_status(
                f"Exported {exported_count} class(es) to shapefiles", "info")
        else:
            self._update_status("No segments found to export!", "warning")

    # Include all the other methods from the previous implementation
    def _get_adaptive_crop_size(self):
        """Calculate crop size based on current zoom level"""
        canvas_scale = self.canvas.scale()
        base_size = 512

        if canvas_scale > 100000:  # Very zoomed out
            crop_size = 1024
        elif canvas_scale > 50000:  # Moderately zoomed out
            crop_size = 768
        elif canvas_scale < 1000:   # Very zoomed in
            crop_size = 256
        else:  # Normal zoom
            crop_size = base_size

        return crop_size

    def _get_or_create_class_layer(self, class_name):
        """Get existing layer for class or create new one with color info"""
        if class_name in self.result_layers and self.result_layers[class_name]:
            return self.result_layers[class_name]

        # Create new layer for this class
        rlayer = self.iface.activeLayer()
        class_info = self.classes.get(class_name, {'color': '128,128,128'})
        color = class_info['color']

        layer_name = f"SAM_{class_name}_{datetime.datetime.now():%H%M%S} [RGB:{color}]"

        layer = QgsVectorLayer(f"Polygon?crs={rlayer.crs().authid()}",
                               layer_name, "memory")

        # Add attributes for tracking
        layer.dataProvider().addAttributes([
            QgsField("segment_id", QVariant.Int),
            QgsField("class_name", QVariant.String),
            QgsField("class_color", QVariant.String),
            QgsField("method", QVariant.String),
            QgsField("timestamp", QVariant.String),
            QgsField("mask_file", QVariant.String),
            QgsField("crop_size", QVariant.String),
            QgsField("canvas_scale", QVariant.Double)
        ])
        layer.updateFields()

        # Apply class-specific styling
        self._apply_class_style(layer, class_name)

        # Add to project and store reference
        QgsProject.instance().addMapLayer(layer)
        self.result_layers[class_name] = layer
        self.segment_counts[class_name] = 0

        return layer

    def _apply_class_style(self, layer, class_name):
        """Apply class-specific styling with enhanced visibility"""
        try:
            class_info = self.classes.get(class_name, {'color': '128,128,128'})
            color = class_info['color']

            # Parse RGB values
            try:
                r, g, b = [int(c.strip()) for c in color.split(',')]
            except:
                r, g, b = 128, 128, 128  # Default gray

            # Create vibrant styling with good contrast
            symbol = QgsFillSymbol.createSimple({
                'color': f'{r},{g},{b},180',        # Semi-transparent fill
                'outline_color': f'{r},{g},{b},255',  # Solid outline
                'outline_width': '1.5',              # Thicker outline
                'outline_style': 'solid'
            })

            layer.renderer().setSymbol(symbol)
            layer.setOpacity(0.85)
            layer.triggerRepaint()

        except Exception as e:
            print(f"Color application failed for {class_name}: {e}")

    def _run_segmentation(self):
        """Run the segmentation process"""
        if not self.current_class:
            self._update_status("No class selected", "error")
            return

        try:
            import tempfile
            import requests
            import numpy as np
            import cv2
            import rasterio
            from rasterio.windows import from_bounds
            from rasterio.features import shapes
            from shapely.geometry import shape
        except ImportError as e:
            self._update_status(f"Missing module: {e.name}", "error")
            return

        rlayer = self.iface.activeLayer()
        if not isinstance(rlayer, QgsRasterLayer):
            self._update_status("Select a raster layer first", "error")
            return

        if self.point is None and self.bbox is None:
            self._update_status("No selection found", "error")
            return

        rpath = rlayer.source()

        # Get current map scale/zoom for adaptive cropping
        canvas_scale = self.canvas.scale()
        adaptive_crop_size = self._get_adaptive_crop_size()

        # ---------- Build PNG and convert coordinates to pixels ----------
        with rasterio.open(rpath) as src:
            if self.point is not None:  # POINT MODE
                # Convert geo point to pixel coordinates
                row, col = src.index(self.point.x(), self.point.y())
                center_pixel_x, center_pixel_y = col, row

                # Use adaptive crop size based on zoom level
                crop_size = adaptive_crop_size
                half_size = crop_size // 2

                # Calculate crop bounds in pixel coordinates
                x_min = max(0, center_pixel_x - half_size)
                y_min = max(0, center_pixel_y - half_size)
                x_max = min(src.width, center_pixel_x + half_size)
                y_max = min(src.height, center_pixel_y + half_size)

                # Ensure we have a valid crop area
                if x_max <= x_min or y_max <= y_min:
                    self._update_status("Invalid crop area for point", "error")
                    return

                # Create window for cropping
                window = rasterio.windows.Window(
                    x_min, y_min, x_max - x_min, y_max - y_min)

                # Read cropped area
                try:
                    arr = src.read([1, 2, 3], window=window)
                    if arr.size == 0:
                        self._update_status("Empty crop area", "error")
                        return
                except Exception as e:
                    self._update_status(f"Error reading raster: {e}", "error")
                    return

                arr = np.moveaxis(arr, 0, -1)

                # Normalize to 0-255
                if arr.max() > arr.min():
                    arr = ((arr - arr.min()) / (arr.max() - arr.min())
                           * 255).astype(np.uint8)
                else:
                    arr = np.zeros_like(arr, dtype=np.uint8)

                # Point coordinates relative to cropped image
                relative_x = center_pixel_x - x_min
                relative_y = center_pixel_y - y_min

                # Ensure point is within crop bounds
                relative_x = max(0, min(arr.shape[1] - 1, relative_x))
                relative_y = max(0, min(arr.shape[0] - 1, relative_y))

                url = f"{self.API_BASE}/segment?x={relative_x}&y={relative_y}"
                payload = {}

                # Use window transform for mask conversion
                mask_transform = src.window_transform(window)

                debug_info = {
                    'mode': 'POINT',
                    'class': self.current_class,
                    'actual_crop': f"{arr.shape[1]}x{arr.shape[0]}"
                }

            else:  # BBOX MODE
                # Create window from bbox bounds
                try:
                    window = rasterio.windows.from_bounds(
                        self.bbox.xMinimum(), self.bbox.yMinimum(),
                        self.bbox.xMaximum(), self.bbox.yMaximum(),
                        src.transform
                    )
                except Exception as e:
                    self._update_status(
                        f"Error creating bbox window: {e}", "error")
                    return

                # Ensure window is valid
                if window.width <= 0 or window.height <= 0:
                    self._update_status("Invalid bbox dimensions", "error")
                    return

                # Read cropped area
                try:
                    arr = src.read([1, 2, 3], window=window)
                    if arr.size == 0:
                        self._update_status("Empty bbox crop area", "error")
                        return
                except Exception as e:
                    self._update_status(
                        f"Error reading bbox raster: {e}", "error")
                    return

                arr = np.moveaxis(arr, 0, -1)

                # Normalize to 0-255
                if arr.max() > arr.min():
                    arr = ((arr - arr.min()) / (arr.max() - arr.min())
                           * 255).astype(np.uint8)
                else:
                    arr = np.zeros_like(arr, dtype=np.uint8)

                # Calculate CENTER POINT of the bbox in pixel coordinates
                height, width = arr.shape[:2]
                center_x = width // 2
                center_y = height // 2

                # Send center point of bbox
                url = f"{self.API_BASE}/segment?x={center_x}&y={center_y}"
                payload = {}

                # Use window transform for mask conversion
                mask_transform = src.window_transform(window)

                debug_info = {
                    'mode': 'BBOX',
                    'class': self.current_class,
                    'crop_size': f"{width}x{height}"
                }

        # Validate final array
        if arr.shape[0] == 0 or arr.shape[1] == 0:
            self._update_status("Final crop array is empty", "error")
            return

        # ---------- Write temp PNG ----------
        tmp_png = tempfile.NamedTemporaryFile(suffix=".png", delete=False)
        try:
            success = cv2.imwrite(tmp_png.name, arr)
            if not success:
                self._update_status("Failed to write PNG", "error")
                return
        except Exception as e:
            self._update_status(f"Error writing PNG: {e}", "error")
            return

        # ---------- API Request ----------
        try:
            with open(tmp_png.name, "rb") as f:
                files = {"file": (os.path.basename(
                    tmp_png.name), f, "image/png")}
                resp = requests.post(
                    url, data=payload, files=files, timeout=60)
        except requests.exceptions.Timeout:
            self._update_status("API request timed out", "error")
            return
        except requests.exceptions.ConnectionError:
            self._update_status("Cannot connect to API server", "error")
            return
        except Exception as exc:
            self._update_status(f"API error: {exc}", "error")
            return
        finally:
            # Clean up temp file
            try:
                os.unlink(tmp_png.name)
            except:
                pass

        if resp.status_code != 200:
            self._update_status(
                f"API error {resp.status_code}: {resp.text}", "error")
            return

        # ---------- Save mask from API response ----------
        mask_filename = self._save_mask_from_response(resp.content)

        # ---------- Process mask ‚Üí polygons ----------
        try:
            mask = cv2.imdecode(np.frombuffer(
                resp.content, np.uint8), cv2.IMREAD_GRAYSCALE)
            if mask is None:
                self._update_status("Failed to decode mask image", "error")
                return
        except Exception as e:
            self._update_status(f"Error decoding mask: {e}", "error")
            return

        # Threshold mask to binary
        try:
            _, binary = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)
        except Exception as e:
            self._update_status(f"Error thresholding mask: {e}", "error")
            return

        # Convert mask to features
        feats = []
        try:
            for geom, _ in shapes(binary, mask=binary > 0, transform=mask_transform):
                shp_geom = shape(geom)

                if not shp_geom.is_valid:
                    shp_geom = shp_geom.buffer(0)

                if shp_geom.is_empty:
                    continue

                # Convert to QGIS geometry safely
                if hasattr(shp_geom, 'exterior'):  # Polygon
                    coords = list(shp_geom.exterior.coords)
                    qgs_points = []
                    for coord in coords:
                        if len(coord) >= 2:
                            qgs_points.append(QgsPointXY(coord[0], coord[1]))
                    if len(qgs_points) >= 3:
                        qgs_geom = QgsGeometry.fromPolygonXY([qgs_points])
                    else:
                        continue
                else:
                    try:
                        wkt_str = shp_geom.wkt
                        qgs_geom = QgsGeometry.fromWkt(wkt_str)
                    except Exception as e:
                        continue

                if not qgs_geom.isNull() and not qgs_geom.isEmpty():
                    f = QgsFeature()
                    f.setGeometry(qgs_geom)
                    feats.append(f)

        except Exception as e:
            self._update_status(
                f"Error processing geometries: {str(e)}", "error")
            return

        if not feats:
            self._update_status("No segments found", "warning")
            return

        # ---------- Add to class-specific layer ----------
        result_layer = self._get_or_create_class_layer(self.current_class)

        # Add attributes to new features
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        crop_info = debug_info.get(
            'crop_size', 'unknown') if self.current_mode == 'bbox' else debug_info.get('actual_crop', 'unknown')
        class_color = self.classes.get(
            self.current_class, {}).get('color', '128,128,128')

        for feat in feats:
            self.segment_counts[self.current_class] += 1
            feat.setAttributes([
                self.segment_counts[self.current_class],
                self.current_class,
                class_color,
                self.current_mode,
                timestamp,
                mask_filename,
                crop_info,
                canvas_scale
            ])

        # Add new features to class layer
        try:
            result_layer.dataProvider().addFeatures(feats)
            result_layer.updateExtents()
            result_layer.triggerRepaint()
        except Exception as e:
            self._update_status(f"Error adding features: {e}", "error")
            return

        # Update layer name with count
        total_features = result_layer.featureCount()
        color_info = f" [RGB:{class_color}]"
        new_layer_name = f"SAM_{self.current_class} ({total_features} parts){color_info}"
        result_layer.setName(new_layer_name)

        # Clear visual feedback from tools
        if self.current_mode == 'point':
            self.pointTool.clear_feedback()
        elif self.current_mode == 'bbox':
            self.bboxTool.clear_feedback()

        # Update status and stats
        self._update_status(
            f"‚úÖ Added {len(feats)} [{self.current_class}] segments! Click again to add more.", "info")
        self._update_stats()

    def _save_mask_from_response(self, mask_content):
        """Save the mask returned from API to disk with class info"""
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            class_prefix = f"{self.current_class}_" if self.current_class else ""

            if self.current_mode == 'point':
                filename = f"mask_{class_prefix}point_{self.point.x():.1f}_{self.point.y():.1f}_{timestamp}.png"
            else:  # bbox
                filename = f"mask_{class_prefix}bbox_{self.bbox.width():.1f}x{self.bbox.height():.1f}_{timestamp}.png"

            # Clean filename
            filename = "".join(
                c for c in filename if c.isalnum() or c in "._-")

            mask_path = self.mask_save_dir / filename

            # Save mask content to file
            with open(mask_path, "wb") as f:
                f.write(mask_content)

            return filename

        except Exception as e:
            print(f"‚ùå Failed to save mask: {e}")
            return "save_failed"

    def _export_layer_to_shapefile(self, layer, class_name):
        """Export a class layer to shapefile"""
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            shapefile_name = f"SAM_{class_name}_{timestamp}.shp"
            shapefile_path = str(self.shapefile_save_dir / shapefile_name)

            # Export layer to shapefile
            error = QgsVectorFileWriter.writeAsVectorFormat(
                layer,
                shapefile_path,
                "utf-8",
                layer.crs(),
                "ESRI Shapefile"
            )

            if error[0] == QgsVectorFileWriter.NoError:
                print(f"üíæ Exported {class_name}: {shapefile_path}")
                return True
            else:
                print(f"‚ùå Export failed for {class_name}: {error}")
                return False

        except Exception as e:
            print(f"‚ùå Export error for {class_name}: {e}")
            return False


# ----------------------------------------------------------------------
# Updated main dialog class for compatibility
# ----------------------------------------------------------------------

class SegSamDialog(QtWidgets.QDialog):
    """Simple dialog that creates and shows the control panel"""

    def __init__(self, iface, parent=None):
        super().__init__(parent)
        self.iface = iface
        self.control_panel = None

        # Simple dialog layout
        layout = QtWidgets.QVBoxLayout(self)

        label = QtWidgets.QLabel("GeoOSAM Control Panel")
        label.setStyleSheet(
            "font-size: 14px; font-weight: bold; padding: 10px;")
        layout.addWidget(label)

        show_panel_btn = QtWidgets.QPushButton("Show Control Panel")
        show_panel_btn.clicked.connect(self._show_control_panel)
        layout.addWidget(show_panel_btn)

        close_btn = QtWidgets.QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setWindowTitle("GeoOSAM")
        self.resize(250, 120)

    def _show_control_panel(self):
        """Show the dockable control panel"""
        if not self.control_panel:
            self.control_panel = GeoOSAMControlPanel(self.iface)
            self.iface.addDockWidget(
                Qt.RightDockWidgetArea, self.control_panel)

        self.control_panel.show()
        self.control_panel.raise_()

        # Close this dialog
        self.close()
