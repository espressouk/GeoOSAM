import sys
from qgis.PyQt import QtWidgets, uic, QtCore, QtGui
from qgis.gui import QgsMapToolEmitPoint, QgsRubberBand, QgsMapTool
from qgis.core import (
    QgsProject,
    QgsRasterLayer,
    QgsRectangle,
    QgsWkbTypes,
    QgsPointXY,
    QgsVectorLayer,
    QgsFeature,
    QgsGeometry,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFillSymbol,
    QgsMarkerSymbol,
    QgsField,
    QgsMessageLog,
    Qgis,
    QgsVectorFileWriter
)
from qgis.PyQt.QtCore import QVariant, Qt, QThread, pyqtSignal, QObject
import pathlib
import datetime
import shutil
import io
import torch
import numpy as np
import cv2
import rasterio
from rasterio.features import shapes
from shapely.geometry import shape
from hydra import initialize_config_module, compose
from hydra.core.global_hydra import GlobalHydra
# fmt: off
import sys, os
plugin_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(plugin_dir)
from sam2.build_sam import build_sam2
from sam2.sam2_image_predictor import SAM2ImagePredictor

"""
/***************************************************************************
 GeoOSAM Control Panel - Complete Version with Threading and Raster Selection
                                 A QGIS plugin
 generate poly using SAM with enhanced UX, performance optimization, and workflow improvements
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-26
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Ofer Butbega
        email                : ofer@butbega.com
 ***************************************************************************/
"""

# ----------------------------------------------------------------------
# Performance Configuration
# ----------------------------------------------------------------------
def setup_pytorch_performance():
    """Configure PyTorch for optimal performance with safety checks"""
    try:
        import multiprocessing
        num_cores = multiprocessing.cpu_count()

        # Use most cores but leave some for system
        optimal_threads = max(1, num_cores - 1) if num_cores > 2 else num_cores

        # Set number of threads for CPU operations
        torch.set_num_threads(optimal_threads)
        torch.set_num_interop_threads(optimal_threads)

        # Enable safe optimizations
        try:
            torch.backends.mkldnn.enabled = True
        except:
            pass  # Skip if not available

        # Safe CUDNN settings
        if hasattr(torch.backends, 'cudnn'):
            try:
                torch.backends.cudnn.benchmark = True
                torch.backends.cudnn.deterministic = False
            except:
                pass  # Skip if CUDNN not available

        print(f"ðŸš€ PyTorch configured for {optimal_threads}/{num_cores} CPU cores")
        return optimal_threads

    except Exception as e:
        print(f"âš ï¸ Performance setup failed: {e}, using defaults")
        return 1

def detect_best_device():
    """Detect the best available device for inference with conservative settings"""
    try:
        if torch.cuda.is_available():
            device = "cuda"
            gpu_name = torch.cuda.get_device_name(0)
            gpu_memory = torch.cuda.get_device_properties(0).total_memory / 1024**3
            print(f"ðŸŽ® GPU detected: {gpu_name} ({gpu_memory:.1f}GB)")
        elif hasattr(torch.backends, 'mps') and torch.backends.mps.is_available():
            device = "mps"  # Apple Silicon
            print("ðŸŽ Apple Silicon GPU detected")
        else:
            device = "cpu"
            cores = setup_pytorch_performance()
            print(f"ðŸ’» Using CPU with {cores} cores")
    except Exception as e:
        print(f"âš ï¸ Device detection failed: {e}, falling back to CPU")
        device = "cpu"
        setup_pytorch_performance()

    return device

# ----------------------------------------------------------------------
# Optimized SAM2 Worker Thread
# ----------------------------------------------------------------------
class OptimizedSAM2Worker(QThread):
    finished = pyqtSignal(object)
    error = pyqtSignal(str)
    progress = pyqtSignal(str)

    def __init__(self, predictor, arr, mode, point_coords=None, point_labels=None, 
                 box=None, mask_transform=None, debug_info=None, device="cpu"):
        super().__init__()
        self.predictor = predictor
        self.arr = arr
        self.mode = mode
        self.point_coords = point_coords
        self.point_labels = point_labels
        self.box = box
        self.mask_transform = mask_transform
        self.debug_info = debug_info or {}
        self.device = device

    def run(self):
        try:
            # Configure this thread for optimal performance
            if self.device == "cpu":
                # Use all available CPU cores in this thread
                import multiprocessing
                torch.set_num_threads(multiprocessing.cpu_count())

            self.progress.emit("ðŸ–¼ï¸ Setting image for SAM model...")

            # Safe image preprocessing without type mismatches
            self.predictor.set_image(self.arr)

            self.progress.emit("ðŸ§  Running SAM inference...")

            # Use stable inference without mixed precision issues
            with torch.no_grad():  # Stable inference mode
                if self.mode == "point":
                    masks, scores, logits = self.predictor.predict(
                        point_coords=self.point_coords,
                        point_labels=self.point_labels,
                        multimask_output=False
                    )
                elif self.mode == "bbox":
                    masks, scores, logits = self.predictor.predict(
                        box=self.box,
                        multimask_output=False
                    )
                else:
                    raise ValueError(f"Unknown mode: {self.mode}")

            self.progress.emit("âš¡ Processing mask...")

            # Safe mask processing
            mask = masks[0]
            if hasattr(mask, 'cpu'):  # If it's a tensor
                mask = mask.cpu().numpy()
            elif torch.is_tensor(mask):
                mask = mask.detach().cpu().numpy()

            # Ensure proper data type
            mask = (mask * 255).astype(np.uint8)

            # Return results
            result = {
                'mask': mask,
                'scores': scores,
                'logits': logits,
                'mask_transform': self.mask_transform,
                'debug_info': self.debug_info
            }

            self.finished.emit(result)

        except Exception as e:
            import traceback
            error_msg = f"SAM inference failed: {str(e)}\n{traceback.format_exc()}"
            self.error.emit(error_msg)

# ----------------------------------------------------------------------
# Enhanced map-tools
# ----------------------------------------------------------------------
class EnhancedPointClickTool(QgsMapTool):
    def __init__(self, canvas, cb):
        super().__init__(canvas)
        self.canvas = canvas
        self.cb = cb
        self.setCursor(QtCore.Qt.CrossCursor)

        self.point_rubber = QgsRubberBand(canvas, QgsWkbTypes.PointGeometry)
        self.point_rubber.setColor(QtCore.Qt.red)
        self.point_rubber.setIcon(QgsRubberBand.ICON_CIRCLE)
        self.point_rubber.setIconSize(12)
        self.point_rubber.setWidth(4)
        self.last_click_point = None

    def canvasReleaseEvent(self, e):
        map_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
        self.last_click_point = map_point
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.point_rubber.addPoint(map_point, True)
        self.canvas.refresh()
        self.cb(map_point)

    def deactivate(self):
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.last_click_point = None
        super().deactivate()

    def clear_feedback(self):
        self.point_rubber.reset(QgsWkbTypes.PointGeometry)
        self.canvas.refresh()
        self.last_click_point = None

class EnhancedBBoxClickTool(QgsMapTool):
    def __init__(self, canvas, cb):
        super().__init__(canvas)
        self.canvas = canvas
        self.cb = cb
        self.setCursor(QtCore.Qt.CrossCursor)
        self.start_point = None
        self.is_dragging = False

        self.bbox_rubber = QgsRubberBand(canvas, QgsWkbTypes.PolygonGeometry)
        self.bbox_rubber.setColor(QtCore.Qt.blue)
        self.bbox_rubber.setFillColor(QtGui.QColor(0, 0, 255, 60))
        self.bbox_rubber.setWidth(2)

    def canvasPressEvent(self, e):
        self.start_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
        self.is_dragging = True
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)

    def canvasMoveEvent(self, e):
        if self.is_dragging and self.start_point:
            current_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
            rect = QgsRectangle(self.start_point, current_point)
            self.bbox_rubber.setToGeometry(QgsGeometry.fromRect(rect), None)
            self.canvas.refresh()

    def canvasReleaseEvent(self, e):
        if self.is_dragging and self.start_point:
            end_point = self.canvas.getCoordinateTransform().toMapCoordinates(e.pos())
            rect = QgsRectangle(self.start_point, end_point)
            if rect.width() > 10 and rect.height() > 10:
                self.cb(rect)
            else:
                self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
                self.canvas.refresh()
        self.is_dragging = False
        self.start_point = None

    def deactivate(self):
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
        self.is_dragging = False
        self.start_point = None
        super().deactivate()

    def clear_feedback(self):
        self.bbox_rubber.reset(QgsWkbTypes.PolygonGeometry)
        self.canvas.refresh()

# ----------------------------------------------------------------------
# Complete GeoOSAM Control Panel with All Features
# ----------------------------------------------------------------------

class GeoOSAMControlPanel(QtWidgets.QDockWidget):
    """Complete performance-optimized dockable control panel with raster auto-selection"""

    # Default class definitions
    DEFAULT_CLASSES = {
        'Buildings': {'color': '220,20,60', 'description': 'Residential and commercial buildings'},
        'Roads': {'color': '105,105,105', 'description': 'Streets, highways, and pathways'},
        'Vegetation': {'color': '34,139,34', 'description': 'Trees, grass, and vegetation'},
        'Water': {'color': '30,144,255', 'description': 'Rivers, lakes, and water bodies'},
        'Agriculture': {'color': '255,215,0', 'description': 'Farmland and crops'},
        'Parking': {'color': '255,140,0', 'description': 'Parking lots and areas'},
        'Industrial': {'color': '138,43,226', 'description': 'Industrial buildings and areas'},
        'Residential': {'color': '255,20,147', 'description': 'Residential areas'},
        'Commercial': {'color': '0,191,255', 'description': 'Commercial areas'},
        'Other': {'color': '148,0,211', 'description': 'Unclassified objects'}
    }

    EXTRA_COLORS = [
        '255,69,0', '50,205,50', '255,20,147', '0,206,209', '255,165,0',
        '186,85,211', '0,128,128', '255,192,203', '165,42,42', '0,250,154',
        '255,0,255', '127,255,212', '255,99,71', '72,61,139', '218,165,32'
    ]

    def __init__(self, iface, parent=None):
        super().__init__("GeoOSAM Control Panel", parent)
        self.iface = iface
        self.canvas = iface.mapCanvas()

        # Performance setup
        self.device = detect_best_device()
        self.num_cores = setup_pytorch_performance()

        # Initialize optimized SAM model
        self._init_optimized_sam_model()

        # Make dockable
        self.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.setFeatures(QtWidgets.QDockWidget.DockWidgetMovable |
                         QtWidgets.QDockWidget.DockWidgetFloatable)

        # State variables
        self.point = None
        self.bbox = None
        self.current_mode = None
        self.result_layers = {}
        self.segment_counts = {}
        self.mask_save_dir = None
        self.shapefile_save_dir = None
        self.current_class = None
        self.classes = self.DEFAULT_CLASSES.copy()
        self.worker = None

        # NEW: Raster layer management
        self.original_raster_layer = None
        self.keep_raster_selected = True

        # Initialize directories
        self._init_save_directories()

        # Enhanced map tools
        self.pointTool = EnhancedPointClickTool(self.canvas, self._point_done)
        self.bboxTool = EnhancedBBoxClickTool(self.canvas, self._bbox_done)
        self.original_map_tool = None

        # Setup UI
        self._setup_ui()

    def _init_optimized_sam_model(self):
        """Initialize SAM model with performance optimizations"""
        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        checkpoint_path = os.path.join(plugin_dir, "sam2", "checkpoints", "sam2_hiera_tiny.pt")

        if GlobalHydra.instance().is_initialized():
            GlobalHydra.instance().clear()

        try:
            with initialize_config_module(config_module="sam2.configs"):
                # Build model with optimized device
                sam_model = build_sam2("sam2/sam2_hiera_t", checkpoint_path, device=self.device)

                # Apply safe optimizations without type mismatches
                if self.device == "cuda":
                    sam_model = sam_model.cuda()
                    # Enable optimizations but avoid FP16 issues
                    sam_model.eval()  # Set to evaluation mode for inference
                    # Note: Removed .half() to avoid type mismatch issues
                elif self.device == "cpu":
                    # CPU optimizations
                    sam_model.eval()
                    try:
                        # Only apply JIT optimization if supported
                        sam_model = torch.jit.optimize_for_inference(sam_model)
                    except:
                        pass  # Continue without JIT if not supported

                self.predictor = SAM2ImagePredictor(sam_model)
                self.use_mixed_precision = False  # Disable mixed precision for stability

                print(f"âœ… SAM2 model loaded on {self.device}")

        except Exception as e:
            print(f"âŒ Failed to load optimized SAM model: {e}")
            # Fallback to CPU with basic settings
            self.device = "cpu"
            self.use_mixed_precision = False
            with initialize_config_module(config_module="sam2.configs"):
                sam_model = build_sam2("sam2/sam2_hiera_t", checkpoint_path, device="cpu")
                self.predictor = SAM2ImagePredictor(sam_model)

    def _init_save_directories(self):
        """Initialize directories for saving masks and shapefiles"""
        self.mask_save_dir = pathlib.Path.home() / "GeoOSAM_masks"
        self.mask_save_dir.mkdir(exist_ok=True)
        self.shapefile_save_dir = pathlib.Path.home() / "GeoOSAM_shapefiles"
        self.shapefile_save_dir.mkdir(exist_ok=True)

    def _setup_ui(self):
        """Setup the control panel UI with performance indicators"""
        main_widget = QtWidgets.QWidget()
        self.setWidget(main_widget)
        layout = QtWidgets.QVBoxLayout(main_widget)
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)

        # Title with performance info
        device_icon = "ðŸŽ®" if "cuda" in self.device else "ðŸŽ" if "mps" in self.device else "ðŸ’»"
        title = QtWidgets.QLabel(f"ðŸ›°ï¸ GeoOSAM Control Panel")
        title.setStyleSheet("font-size: 14px; font-weight: bold; color: #2E86AB; padding: 5px;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)

        # Performance indicator
        perf_info = f"{device_icon} {self.device.upper()}"
        if self.device == "cpu":
            perf_info += f" ({self.num_cores} cores)"

        perf_label = QtWidgets.QLabel(perf_info)
        perf_label.setStyleSheet("font-size: 10px; color: #666; text-align: center; padding: 2px;")
        perf_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(perf_label)

        # Separator
        separator1 = QtWidgets.QFrame()
        separator1.setFrameShape(QtWidgets.QFrame.HLine)
        separator1.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator1)

        # Class Selection Section
        self._setup_class_section(layout)

        separator2 = QtWidgets.QFrame()
        separator2.setFrameShape(QtWidgets.QFrame.HLine)
        separator2.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator2)

        # Mode Selection Section
        self._setup_mode_section(layout)

        separator3 = QtWidgets.QFrame()
        separator3.setFrameShape(QtWidgets.QFrame.HLine)
        separator3.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator3)

        # Status Section
        self._setup_status_section(layout)

        separator4 = QtWidgets.QFrame()
        separator4.setFrameShape(QtWidgets.QFrame.HLine)
        separator4.setFrameShadow(QtWidgets.QFrame.Sunken)
        layout.addWidget(separator4)

        # Control Buttons Section (Enhanced with raster selection)
        self._setup_control_section(layout)

        layout.addStretch()
        self.setMinimumWidth(280)
        self.setMaximumWidth(350)

    def _setup_class_section(self, layout):
        """Setup class selection section"""
        class_header = QtWidgets.QLabel("ðŸ“‹ Class Selection")
        class_header.setStyleSheet("font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(class_header)

        self.classComboBox = QtWidgets.QComboBox()
        self.classComboBox.addItem("-- Select Class --", None)
        for class_name, class_info in self.classes.items():
            self.classComboBox.addItem(f"{class_name}", class_name)
        self.classComboBox.currentTextChanged.connect(self._on_class_changed)
        self.classComboBox.setStyleSheet("padding: 4px; font-size: 11px;")
        layout.addWidget(self.classComboBox)

        self.currentClassLabel = QtWidgets.QLabel("Current Class: None")
        self.currentClassLabel.setStyleSheet(
            "font-weight: bold; padding: 8px; border: 2px solid gray; "
            "background-color: rgba(200,200,200,50); border-radius: 4px; font-size: 11px;")
        self.currentClassLabel.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.currentClassLabel)

        class_btn_layout = QtWidgets.QHBoxLayout()
        self.addClassBtn = QtWidgets.QPushButton("âž• Add")
        self.addClassBtn.clicked.connect(self._add_new_class)
        self.addClassBtn.setStyleSheet("font-size: 10px; padding: 4px;")
        class_btn_layout.addWidget(self.addClassBtn)

        self.editClassBtn = QtWidgets.QPushButton("âœï¸ Edit")
        self.editClassBtn.clicked.connect(self._edit_classes)
        self.editClassBtn.setStyleSheet("font-size: 10px; padding: 4px;")
        class_btn_layout.addWidget(self.editClassBtn)
        layout.addLayout(class_btn_layout)

    def _setup_mode_section(self, layout):
        """Setup mode selection section"""
        mode_header = QtWidgets.QLabel("ðŸŽ¯ Segmentation Mode")
        mode_header.setStyleSheet("font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(mode_header)

        mode_layout = QtWidgets.QVBoxLayout()
        self.pointModeBtn = QtWidgets.QPushButton("ðŸŽ¯ Point Mode")
        self.pointModeBtn.clicked.connect(self._activate_point_tool)
        self.pointModeBtn.setStyleSheet(
            "padding: 8px; font-size: 12px; font-weight: bold; "
            "background-color: #4CAF50; color: white; border-radius: 4px;")
        mode_layout.addWidget(self.pointModeBtn)

        self.bboxModeBtn = QtWidgets.QPushButton("ðŸ“¦ BBox Mode")
        self.bboxModeBtn.clicked.connect(self._activate_bbox_tool)
        self.bboxModeBtn.setStyleSheet(
            "padding: 8px; font-size: 12px; font-weight: bold; "
            "background-color: #2196F3; color: white; border-radius: 4px;")
        mode_layout.addWidget(self.bboxModeBtn)
        layout.addLayout(mode_layout)

        self.currentModeLabel = QtWidgets.QLabel("Mode: None")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #f0f0f0; border-radius: 3px; font-size: 10px;")
        self.currentModeLabel.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.currentModeLabel)

    def _setup_status_section(self, layout):
        """Setup status display section"""
        status_header = QtWidgets.QLabel("ðŸ“Š Status")
        status_header.setStyleSheet("font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(status_header)

        self.statusLabel = QtWidgets.QLabel("Ready to segment")
        self.statusLabel.setStyleSheet(
            "padding: 6px; background-color: #e8f5e8; border-left: 4px solid #4CAF50; "
            "font-size: 10px; border-radius: 3px;")
        self.statusLabel.setWordWrap(True)
        layout.addWidget(self.statusLabel)

        self.statsLabel = QtWidgets.QLabel("Total Segments: 0")
        self.statsLabel.setStyleSheet("font-size: 10px; color: #666; padding: 2px;")
        layout.addWidget(self.statsLabel)

    def _setup_control_section(self, layout):
        """Enhanced control section with raster selection option"""
        control_header = QtWidgets.QLabel("âš™ï¸ Controls")
        control_header.setStyleSheet("font-size: 12px; font-weight: bold; color: #2E86AB;")
        layout.addWidget(control_header)

        # Progress bar (initially hidden)
        self.progressBar = QtWidgets.QProgressBar()
        self.progressBar.setRange(0, 0)
        self.progressBar.setVisible(False)
        self.progressBar.setStyleSheet("QProgressBar { border: 1px solid #ccc; border-radius: 3px; }")
        layout.addWidget(self.progressBar)

        # NEW: Toggle for keeping raster selected
        self.keepRasterCheckbox = QtWidgets.QCheckBox("ðŸŽ¯ Keep raster layer selected")
        self.keepRasterCheckbox.setChecked(True)
        self.keepRasterCheckbox.setStyleSheet("font-size: 10px; padding: 4px;")
        self.keepRasterCheckbox.toggled.connect(self._on_keep_raster_toggled)
        layout.addWidget(self.keepRasterCheckbox)

        # Control buttons
        control_layout = QtWidgets.QVBoxLayout()

        # Cancel button (initially hidden)
        self.cancelBtn = QtWidgets.QPushButton("âŒ Cancel Processing")
        self.cancelBtn.clicked.connect(self._cancel_segmentation)
        self.cancelBtn.setVisible(False)
        self.cancelBtn.setStyleSheet("padding: 6px; font-size: 10px; background-color: #f44336; color: white; border-radius: 3px;")
        control_layout.addWidget(self.cancelBtn)

        # NEW: Manual raster reselect button
        self.reselectRasterBtn = QtWidgets.QPushButton("ðŸ“¡ Reselect Raster")
        self.reselectRasterBtn.clicked.connect(self._reselect_raster)
        self.reselectRasterBtn.setStyleSheet("padding: 6px; font-size: 10px; background-color: #795548; color: white; border-radius: 3px;")
        control_layout.addWidget(self.reselectRasterBtn)

        self.clearBtn = QtWidgets.QPushButton("ðŸ”„ Clear Selection")
        self.clearBtn.clicked.connect(self._clear_current_selection)
        self.clearBtn.setStyleSheet("padding: 6px; font-size: 10px; background-color: #FFC107; border-radius: 3px;")
        control_layout.addWidget(self.clearBtn)

        self.newShapeBtn = QtWidgets.QPushButton("ðŸ†• New Shape")
        self.newShapeBtn.clicked.connect(self._start_new_shape)
        self.newShapeBtn.setStyleSheet("padding: 6px; font-size: 10px; background-color: #FF9800; border-radius: 3px;")
        control_layout.addWidget(self.newShapeBtn)

        self.exportBtn = QtWidgets.QPushButton("ðŸ’¾ Export All")
        self.exportBtn.clicked.connect(self._export_all_classes)
        self.exportBtn.setStyleSheet("padding: 6px; font-size: 10px; background-color: #9C27B0; color: white; border-radius: 3px;")
        control_layout.addWidget(self.exportBtn)

        layout.addLayout(control_layout)

    # ----------------------------------------------------------------------
    # Raster Layer Management Methods
    # ----------------------------------------------------------------------

    def _on_keep_raster_toggled(self, checked):
        """Handle the keep raster layer selected toggle"""
        self.keep_raster_selected = checked
        if checked:
            self._update_status("âœ… Will keep raster layer selected after segmentation", "info")
            # Immediately reselect raster if available
            self._reselect_raster()
        else:
            self._update_status("Vector layers will be auto-selected after segmentation", "info")

    def _reselect_raster(self):
        """Manually reselect the original raster layer"""
        if self.original_raster_layer:
            self.iface.setActiveLayer(self.original_raster_layer)
            self._update_status(f"ðŸ“¡ Reselected raster: {self.original_raster_layer.name()}", "info")
        else:
            # Try to find any raster layer in the project
            raster_layers = [layer for layer in QgsProject.instance().mapLayers().values() 
                            if isinstance(layer, QgsRasterLayer)]
            if raster_layers:
                self.original_raster_layer = raster_layers[0]
                self.iface.setActiveLayer(self.original_raster_layer)
                self._update_status(f"ðŸ“¡ Selected raster: {self.original_raster_layer.name()}", "info")
            else:
                self._update_status("No raster layers found in project", "warning")

    def _validate_class_selection(self):
        """Enhanced validation that also checks for raster layer"""
        if not self.current_class:
            self._update_status("Please select a class first!", "warning")
            return False

        # Check if we have a raster layer selected
        current_layer = self.iface.activeLayer()
        if not isinstance(current_layer, QgsRasterLayer):
            # Try to auto-select a raster layer
            self._reselect_raster()
            current_layer = self.iface.activeLayer()

            if not isinstance(current_layer, QgsRasterLayer):
                self._update_status("Please select a raster layer first! Use ðŸ“¡ Reselect Raster button.", "warning")
                return False

        return True

    # ----------------------------------------------------------------------
    # Class Management Methods
    # ----------------------------------------------------------------------

    def _update_stats(self):
        """Update statistics display"""
        total_segments = sum(layer.featureCount() for layer in self.result_layers.values() if layer)
        total_classes = len([l for l in self.result_layers.values() if l and l.featureCount() > 0])
        self.statsLabel.setText(f"Total Segments: {total_segments} | Classes: {total_classes}")

    def _on_class_changed(self):
        """Handle class selection change"""
        selected_data = self.classComboBox.currentData()
        if selected_data:
            self.current_class = selected_data
            class_info = self.classes[selected_data]
            self.currentClassLabel.setText(f"Current: {selected_data}")

            color = class_info['color']
            try:
                r, g, b = [int(c.strip()) for c in color.split(',')]
                self.currentClassLabel.setStyleSheet(
                    f"font-weight: bold; padding: 8px; margin: 2px; "
                    f"border: 3px solid rgb({r},{g},{b}); "
                    f"background-color: rgba({r},{g},{b}, 30); "
                    f"color: rgb({max(0, r-50)},{max(0, g-50)},{max(0, b-50)}); "
                    f"border-radius: 4px; font-size: 11px;")
            except:
                self.currentClassLabel.setStyleSheet(
                    f"font-weight: bold; padding: 8px; border: 2px solid rgb({color}); "
                    f"background-color: rgba({color}, 50); font-size: 11px;")
        else:
            self.current_class = None
            self.currentClassLabel.setText("Current: None")
            self.currentClassLabel.setStyleSheet(
                "font-weight: bold; padding: 8px; border: 2px solid gray; "
                "background-color: rgba(200,200,200,50); border-radius: 4px; font-size: 11px;")

    def _add_new_class(self):
        """Add a new class with automatic color assignment"""
        class_name, ok = QtWidgets.QInputDialog.getText(self, 'Add Class', 'Enter class name:')
        if ok and class_name and class_name not in self.classes:
            used_colors = [info['color'] for info in self.classes.values()]
            available_colors = [c for c in self.EXTRA_COLORS if c not in used_colors]

            if available_colors:
                color = available_colors[0]
            else:
                import random
                color = f"{random.randint(100,255)},{random.randint(100,255)},{random.randint(100,255)}"

            description = f'Custom class: {class_name}'
            self.classes[class_name] = {'color': color, 'description': description}
            self.classComboBox.addItem(class_name, class_name)
            self._update_status(f"Added class: {class_name} (RGB:{color})", "info")

    def _edit_classes(self):
        """Edit existing classes"""
        class_list = list(self.classes.keys())
        if not class_list:
            self._update_status("No classes to edit", "warning")
            return

        class_name, ok = QtWidgets.QInputDialog.getItem(
            self, 'Edit Classes', 'Select class to edit:', class_list, 0, False)

        if ok and class_name:
            current_info = self.classes[class_name]
            new_name, ok2 = QtWidgets.QInputDialog.getText(
                self, 'Edit Class Name', f'Edit name for {class_name}:', text=class_name)

            if ok2 and new_name:
                current_color = current_info['color']
                new_color, ok3 = QtWidgets.QInputDialog.getText(
                    self, 'Edit Color', f'Edit color for {new_name} (R,G,B):', text=current_color)

                if ok3 and new_color:
                    try:
                        parts = [int(p.strip()) for p in new_color.split(',')]
                        if len(parts) == 3 and all(0 <= p <= 255 for p in parts):
                            if new_name != class_name:
                                del self.classes[class_name]

                            self.classes[new_name] = {
                                'color': new_color,
                                'description': current_info.get('description', f'Class: {new_name}')
                            }
                            self._refresh_class_combo()
                            self._update_status(f"Updated {new_name} with RGB({new_color})", "info")
                        else:
                            self._update_status("Invalid color format! Use R,G,B (0-255)", "error")
                    except ValueError:
                        self._update_status("Invalid color format! Use R,G,B (0-255)", "error")

    def _refresh_class_combo(self):
        """Refresh the class combo box"""
        current_class = self.current_class
        self.classComboBox.clear()
        self.classComboBox.addItem("-- Select Class --", None)

        for class_name, class_info in self.classes.items():
            self.classComboBox.addItem(class_name, class_name)

        if current_class and current_class in self.classes:
            index = self.classComboBox.findData(current_class)
            if index >= 0:
                self.classComboBox.setCurrentIndex(index)

    # ----------------------------------------------------------------------
    # Mode and Tool Management
    # ----------------------------------------------------------------------

    def _activate_point_tool(self):
        """Activate point segmentation tool"""
        if not self._validate_class_selection():
            return

        self.current_mode = 'point'
        self.original_map_tool = self.canvas.mapTool()

        self.currentModeLabel.setText("Mode: ðŸŽ¯ Point Active")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #4CAF50; color: white; border-radius: 3px; font-size: 10px;")

        self._update_status(f"Point mode active for [{self.current_class}]. Click on map to segment.", "processing")
        self.canvas.setMapTool(self.pointTool)

    def _activate_bbox_tool(self):
        """Activate bbox segmentation tool"""
        if not self._validate_class_selection():
            return

        self.current_mode = 'bbox'
        self.original_map_tool = self.canvas.mapTool()

        self.currentModeLabel.setText("Mode: ðŸ“¦ BBox Active")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #2196F3; color: white; border-radius: 3px; font-size: 10px;")

        self._update_status(f"BBox mode active for [{self.current_class}]. Click and drag to segment.", "processing")
        self.canvas.setMapTool(self.bboxTool)

    def _point_done(self, pt):
        """Handle point tool completion"""
        self.point = pt
        self.bbox = None
        self._update_status(f"Processing point at ({pt.x():.1f}, {pt.y():.1f})...", "processing")
        self._run_segmentation()

    def _bbox_done(self, rect):
        """Handle bbox tool completion"""
        self.bbox = rect
        self.point = None
        self._update_status(f"Processing bbox ({rect.width():.1f}Ã—{rect.height():.1f})...", "processing")
        self._run_segmentation()

    def _clear_current_selection(self):
        """Clear current selection but keep tool active"""
        self.point = None
        self.bbox = None

        if hasattr(self.pointTool, 'clear_feedback'):
            self.pointTool.clear_feedback()
        if hasattr(self.bboxTool, 'clear_feedback'):
            self.bboxTool.clear_feedback()

        class_info = f"[{self.current_class}]" if self.current_class else ""
        if self.current_mode == 'point':
            self._update_status(f"Point mode {class_info}: Ready for next point", "info")
        elif self.current_mode == 'bbox':
            self._update_status(f"BBox mode {class_info}: Ready for next box", "info")
        else:
            self._update_status("Ready to segment", "info")

    def _start_new_shape(self):
        """Start completely new shape (remove existing layers)"""
        self.point = None
        self.bbox = None
        self.current_mode = None

        if hasattr(self.pointTool, 'clear_feedback'):
            self.pointTool.clear_feedback()
        if hasattr(self.bboxTool, 'clear_feedback'):
            self.bboxTool.clear_feedback()

        for class_name, layer in self.result_layers.items():
            if layer:
                QgsProject.instance().removeMapLayer(layer)

        self.result_layers = {}
        self.segment_counts = {}

        if self.original_map_tool:
            self.canvas.setMapTool(self.original_map_tool)

        self.currentModeLabel.setText("Mode: None")
        self.currentModeLabel.setStyleSheet(
            "padding: 4px; background-color: #f0f0f0; border-radius: 3px; font-size: 10px;")

        self._update_status("Ready for new shape. Select class and mode.", "info")
        self._update_stats()

    def _export_all_classes(self):
        """Export all class layers to shapefiles"""
        if not self.result_layers:
            self._update_status("No segments to export!", "warning")
            return

        exported_count = 0
        for class_name, layer in self.result_layers.items():
            if layer and layer.featureCount() > 0:
                if self._export_layer_to_shapefile(layer, class_name):
                    exported_count += 1

        if exported_count > 0:
            self._update_status(f"Exported {exported_count} class(es) to shapefiles", "info")
        else:
            self._update_status("No segments found to export!", "warning")

    # ----------------------------------------------------------------------
    # Threading and Segmentation Methods
    # ----------------------------------------------------------------------

    def _set_ui_enabled(self, enabled):
        """Enhanced UI control including new raster selection controls"""
        self.pointModeBtn.setEnabled(enabled)
        self.bboxModeBtn.setEnabled(enabled)
        self.classComboBox.setEnabled(enabled)
        self.addClassBtn.setEnabled(enabled)
        self.editClassBtn.setEnabled(enabled)
        self.clearBtn.setEnabled(enabled)
        self.newShapeBtn.setEnabled(enabled)
        self.exportBtn.setEnabled(enabled)

        # NEW: Keep raster controls always enabled
        self.keepRasterCheckbox.setEnabled(True)
        self.reselectRasterBtn.setEnabled(True)

        # Show/hide progress elements
        if hasattr(self, 'progressBar'):
            self.progressBar.setVisible(not enabled)
        if hasattr(self, 'cancelBtn'):
            self.cancelBtn.setVisible(not enabled)

        if not enabled:
            self.setCursor(Qt.WaitCursor)
        else:
            self.setCursor(Qt.ArrowCursor)

    def _cancel_segmentation(self):
        """Cancel running segmentation"""
        if hasattr(self, 'worker') and self.worker and self.worker.isRunning():
            self.worker.terminate()
            self.worker.wait()
            self.worker.deleteLater()
            self.worker = None
            self._update_status("Segmentation cancelled", "warning")
            self._set_ui_enabled(True)

    def _run_segmentation(self):
        """Optimized run segmentation with threading support."""
        if not self.current_class:
            self._update_status("No class selected", "error")
            return

        rlayer = self.iface.activeLayer()
        if not isinstance(rlayer, QgsRasterLayer):
            self._update_status("Select a raster layer first", "error")
            return

        if self.point is None and self.bbox is None:
            self._update_status("No selection found", "error")
            return

        # Start timing
        import time
        start_time = time.time()

        self._set_ui_enabled(False)
        self._update_status("ðŸš€ Preparing optimized image data...", "processing")

        try:
            result = self._prepare_optimized_segmentation_data(rlayer)
            if result is None:
                self._set_ui_enabled(True)
                return

            arr, mask_transform, debug_info, input_coords, input_labels, input_box = result
            prep_time = time.time() - start_time

        except Exception as e:
            self._update_status(f"Error preparing data: {e}", "error")
            self._set_ui_enabled(True)
            return

        # Create optimized worker
        mode = "point" if self.point is not None else "bbox"

        self.worker = OptimizedSAM2Worker(
            predictor=self.predictor,
            arr=arr,
            mode=mode,
            point_coords=input_coords,
            point_labels=input_labels,
            box=input_box,
            mask_transform=mask_transform,
            debug_info={**debug_info, 'prep_time': prep_time},
            device=self.device
        )

        # Connect signals
        self.worker.finished.connect(self._on_segmentation_finished)
        self.worker.error.connect(self._on_segmentation_error)
        self.worker.progress.connect(self._on_segmentation_progress)

        # Start optimized worker
        self.worker.start()

    def _prepare_optimized_segmentation_data(self, rlayer):
        """Optimized data preparation with better memory management."""
        rpath = rlayer.source()
        adaptive_crop_size = self._get_adaptive_crop_size()

        # Use optimized rasterio reading
        with rasterio.open(rpath) as src:
            if self.point is not None:  # POINT MODE
                row, col = src.index(self.point.x(), self.point.y())
                center_pixel_x, center_pixel_y = col, row

                crop_size = adaptive_crop_size
                half_size = crop_size // 2

                x_min = max(0, center_pixel_x - half_size)
                y_min = max(0, center_pixel_y - half_size)
                x_max = min(src.width, center_pixel_x + half_size)
                y_max = min(src.height, center_pixel_y + half_size)

                if x_max <= x_min or y_max <= y_min:
                    self._update_status("Invalid crop area for point", "error")
                    return None

                window = rasterio.windows.Window(x_min, y_min, x_max - x_min, y_max - y_min)

                # Optimized reading with specific data types
                try:
                    arr = src.read([1, 2, 3], window=window, out_dtype=np.uint8)
                    if arr.size == 0:
                        self._update_status("Empty crop area", "error")
                        return None
                except Exception as e:
                    self._update_status(f"Error reading raster: {e}", "error")
                    return None

                # Optimized array processing
                arr = np.moveaxis(arr, 0, -1)

                # Fast normalization using vectorized operations
                if arr.max() > arr.min():
                    arr_min, arr_max = arr.min(), arr.max()
                    arr = ((arr.astype(np.float32) - arr_min) / (arr_max - arr_min) * 255).astype(np.uint8)
                else:
                    arr = np.zeros_like(arr, dtype=np.uint8)

                relative_x = center_pixel_x - x_min
                relative_y = center_pixel_y - y_min
                relative_x = max(0, min(arr.shape[1] - 1, relative_x))
                relative_y = max(0, min(arr.shape[0] - 1, relative_y))

                input_coords = np.array([[relative_x, relative_y]])
                input_labels = np.array([1])
                input_box = None
                mask_transform = src.window_transform(window)

                debug_info = {
                    'mode': 'POINT',
                    'class': self.current_class,
                    'actual_crop': f"{arr.shape[1]}x{arr.shape[0]}",
                    'device': self.device
                }

            else:  # BBOX MODE
                try:
                    window = rasterio.windows.from_bounds(
                        self.bbox.xMinimum(), self.bbox.yMinimum(),
                        self.bbox.xMaximum(), self.bbox.yMaximum(),
                        src.transform
                    )
                except Exception as e:
                    self._update_status(f"Error creating bbox window: {e}", "error")
                    return None

                if window.width <= 0 or window.height <= 0:
                    self._update_status("Invalid bbox dimensions", "error")
                    return None

                try:
                    arr = src.read([1, 2, 3], window=window, out_dtype=np.uint8)
                    if arr.size == 0:
                        self._update_status("Empty bbox crop area", "error")
                        return None
                except Exception as e:
                    self._update_status(f"Error reading bbox raster: {e}", "error")
                    return None

                arr = np.moveaxis(arr, 0, -1)
                if arr.max() > arr.min():
                    arr_min, arr_max = arr.min(), arr.max()
                    arr = ((arr.astype(np.float32) - arr_min) / (arr_max - arr_min) * 255).astype(np.uint8)
                else:
                    arr = np.zeros_like(arr, dtype=np.uint8)

                x0, y0 = 0, 0
                x1, y1 = arr.shape[1] - 1, arr.shape[0] - 1
                input_box = np.array([[x0, y0, x1, y1]])
                input_coords = None
                input_labels = None
                mask_transform = src.window_transform(window)

                debug_info = {
                    'mode': 'BBOX',
                    'class': self.current_class,
                    'crop_size': f"{arr.shape[1]}x{arr.shape[0]}",
                    'device': self.device
                }

        return arr, mask_transform, debug_info, input_coords, input_labels, input_box

    def _on_segmentation_progress(self, message):
        """Handle progress updates with timing info."""
        self._update_status(message, "processing")

    def _on_segmentation_error(self, error_message):
        """Handle errors with detailed information."""
        self._update_status(f"âŒ {error_message}", "error")
        self._set_ui_enabled(True)

        if hasattr(self, 'worker') and self.worker:
            self.worker.deleteLater()
            self.worker = None

    def _on_segmentation_finished(self, result):
        """Handle successful completion with performance metrics."""
        try:
            import time
            start_process_time = time.time()

            self._update_status("âœ¨ Processing results...", "processing")

            mask = result['mask']
            mask_transform = result['mask_transform']
            debug_info = result['debug_info']

            # Process results
            self._process_segmentation_result(mask, mask_transform, debug_info)

            # Calculate and display performance metrics
            process_time = time.time() - start_process_time
            prep_time = debug_info.get('prep_time', 0)
            total_time = prep_time + process_time

            device_info = f"({debug_info.get('device', 'unknown')})"
            self._update_status(
                f"âœ… Completed in {total_time:.1f}s {device_info}! Click again to add more.", "info")

        except Exception as e:
            self._update_status(f"Error processing results: {e}", "error")
        finally:
            self._set_ui_enabled(True)
            if hasattr(self, 'worker') and self.worker:
                self.worker.deleteLater()
                self.worker = None

    def _process_segmentation_result(self, mask, mask_transform, debug_info):
        """Process the segmentation result and add to layer while keeping raster selected"""

        # Save mask image for traceability
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        class_prefix = f"{self.current_class}_" if self.current_class else ""

        if self.current_mode == 'point':
            filename = f"mask_{class_prefix}point_{self.point.x():.1f}_{self.point.y():.1f}_{timestamp}.png"
        else:
            filename = f"mask_{class_prefix}bbox_{self.bbox.width():.1f}x{self.bbox.height():.1f}_{timestamp}.png"

        filename = "".join(c for c in filename if c.isalnum() or c in "._-")
        mask_path = self.mask_save_dir / filename

        try:
            cv2.imwrite(str(mask_path), mask)
        except Exception as e:
            self._update_status(f"Failed to save mask: {e}", "error")
            return

        # Threshold mask to binary
        try:
            _, binary = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)
        except Exception as e:
            self._update_status(f"Error thresholding mask: {e}", "error")
            return

        # Convert mask to features
        feats = []
        try:
            for geom, _ in shapes(binary, mask=binary > 0, transform=mask_transform):
                shp_geom = shape(geom)
                if not shp_geom.is_valid:
                    shp_geom = shp_geom.buffer(0)
                if shp_geom.is_empty:
                    continue

                # Convert to QGIS geometry safely
                if hasattr(shp_geom, 'exterior'):
                    coords = list(shp_geom.exterior.coords)
                    qgs_points = []
                    for coord in coords:
                        if len(coord) >= 2:
                            qgs_points.append(QgsPointXY(coord[0], coord[1]))
                    if len(qgs_points) >= 3:
                        qgs_geom = QgsGeometry.fromPolygonXY([qgs_points])
                    else:
                        continue
                else:
                    try:
                        wkt_str = shp_geom.wkt
                        qgs_geom = QgsGeometry.fromWkt(wkt_str)
                    except Exception as e:
                        continue

                if not qgs_geom.isNull() and not qgs_geom.isEmpty():
                    f = QgsFeature()
                    f.setGeometry(qgs_geom)
                    feats.append(f)

        except Exception as e:
            self._update_status(f"Error processing geometries: {str(e)}", "error")
            return

        if not feats:
            self._update_status("No segments found", "warning")
            return

        # Store current raster layer reference
        current_layer = self.iface.activeLayer()
        if isinstance(current_layer, QgsRasterLayer):
            self.original_raster_layer = current_layer

        result_layer = self._get_or_create_class_layer(self.current_class)

        # Add attributes to new features
        timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        crop_info = debug_info.get('crop_size', 'unknown') if self.current_mode == 'bbox' else debug_info.get('actual_crop', 'unknown')
        class_color = self.classes.get(self.current_class, {}).get('color', '128,128,128')
        canvas_scale = self.canvas.scale()

        for feat in feats:
            self.segment_counts[self.current_class] += 1
            feat.setAttributes([
                self.segment_counts[self.current_class],
                self.current_class,
                class_color,
                self.current_mode,
                timestamp_str,
                filename,
                crop_info,
                canvas_scale
            ])

        try:
            result_layer.dataProvider().addFeatures(feats)
            result_layer.updateExtents()
            result_layer.triggerRepaint()

            # CRITICAL: Ensure raster layer stays selected for continued work
            if self.keep_raster_selected and self.original_raster_layer:
                self.iface.setActiveLayer(self.original_raster_layer)

        except Exception as e:
            self._update_status(f"Error adding features: {e}", "error")
            return

        # Update layer name with count
        total_features = result_layer.featureCount()
        color_info = f" [RGB:{class_color}]"
        new_layer_name = f"SAM_{self.current_class} ({total_features} parts){color_info}"
        result_layer.setName(new_layer_name)

        # Clear visual feedback from tools
        if self.current_mode == 'point':
            self.pointTool.clear_feedback()
        elif self.current_mode == 'bbox':
            self.bboxTool.clear_feedback()

        # Update status and stats
        self._update_stats()

    # ----------------------------------------------------------------------
    # Layer Management Methods
    # ----------------------------------------------------------------------

    def _get_or_create_class_layer(self, class_name):
        """Get existing layer for class or create new one with color info"""
        if class_name in self.result_layers and self.result_layers[class_name]:
            return self.result_layers[class_name]

        # Store the current active raster layer before creating vector layer
        rlayer = self.iface.activeLayer()
        if isinstance(rlayer, QgsRasterLayer):
            self.original_raster_layer = rlayer

        # Create new layer for this class
        class_info = self.classes.get(class_name, {'color': '128,128,128'})
        color = class_info['color']

        layer_name = f"SAM_{class_name}_{datetime.datetime.now():%H%M%S} [RGB:{color}]"
        layer = QgsVectorLayer(f"Polygon?crs={rlayer.crs().authid()}", layer_name, "memory")

        # Add attributes for tracking
        layer.dataProvider().addAttributes([
            QgsField("segment_id", QVariant.Int),
            QgsField("class_name", QVariant.String),
            QgsField("class_color", QVariant.String),
            QgsField("method", QVariant.String),
            QgsField("timestamp", QVariant.String),
            QgsField("mask_file", QVariant.String),
            QgsField("crop_size", QVariant.String),
            QgsField("canvas_scale", QVariant.Double)
        ])
        layer.updateFields()

        # Apply class-specific styling
        self._apply_class_style(layer, class_name)

        # Add to project and store reference
        QgsProject.instance().addMapLayer(layer)
        self.result_layers[class_name] = layer
        self.segment_counts[class_name] = 0

        # IMPORTANT: Re-select the original raster layer to continue working
        if self.keep_raster_selected and self.original_raster_layer:
            self.iface.setActiveLayer(self.original_raster_layer)

        return layer

    def _apply_class_style(self, layer, class_name):
        """Apply class-specific styling with enhanced visibility"""
        try:
            class_info = self.classes.get(class_name, {'color': '128,128,128'})
            color = class_info['color']

            try:
                r, g, b = [int(c.strip()) for c in color.split(',')]
            except:
                r, g, b = 128, 128, 128

            symbol = QgsFillSymbol.createSimple({
                'color': f'{r},{g},{b},180',
                'outline_color': f'{r},{g},{b},255',
                'outline_width': '1.5',
                'outline_style': 'solid'
            })

            layer.renderer().setSymbol(symbol)
            layer.setOpacity(0.85)
            layer.triggerRepaint()

        except Exception as e:
            print(f"Color application failed for {class_name}: {e}")

    def _export_layer_to_shapefile(self, layer, class_name):
        """Export a class layer to shapefile"""
        try:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            shapefile_name = f"SAM_{class_name}_{timestamp}.shp"
            shapefile_path = str(self.shapefile_save_dir / shapefile_name)

            error = QgsVectorFileWriter.writeAsVectorFormat(
                layer, shapefile_path, "utf-8", layer.crs(), "ESRI Shapefile")

            if error[0] == QgsVectorFileWriter.NoError:
                print(f"ðŸ’¾ Exported {class_name}: {shapefile_path}")
                return True
            else:
                print(f"âŒ Export failed for {class_name}: {error}")
                return False

        except Exception as e:
            print(f"âŒ Export error for {class_name}: {e}")
            return False

    # ----------------------------------------------------------------------
    # Utility Methods
    # ----------------------------------------------------------------------

    def _get_adaptive_crop_size(self):
        """Calculate crop size based on current zoom level and device capability"""
        canvas_scale = self.canvas.scale()

        # Conservative base sizes to avoid memory issues
        if self.device == "cuda":
            base_size = 768  # Reduced from 1024 for stability
        elif self.device == "mps":
            base_size = 512   # Apple Silicon - conservative
        else:
            base_size = 512   # CPU - keep moderate size

        # Scale based on zoom level
        if canvas_scale > 100000:
            crop_size = min(base_size * 1.5, 1024)  # Cap at 1024 for safety
        elif canvas_scale > 50000:
            crop_size = int(base_size * 1.2)
        elif canvas_scale < 1000:
            crop_size = base_size // 2
        else:
            crop_size = base_size

        # Ensure minimum size
        crop_size = max(256, crop_size)

        print(f"ðŸ“ Using crop size: {crop_size}x{crop_size} for {self.device}")
        return crop_size

    def _update_status(self, message, status_type="info"):
        """Update status display"""
        colors = {
            "info": "#e8f5e8; border-left: 4px solid #4CAF50",
            "warning": "#fff3cd; border-left: 4px solid #FFC107",
            "error": "#f8d7da; border-left: 4px solid #DC3545",
            "processing": "#d4edda; border-left: 4px solid #17a2b8"
        }
        color_style = colors.get(status_type, colors["info"])
        self.statusLabel.setText(message)
        self.statusLabel.setStyleSheet(
            f"padding: 6px; background-color: {color_style}; font-size: 10px; border-radius: 3px;")


# ----------------------------------------------------------------------
# Dialog class for compatibility
# ----------------------------------------------------------------------

class SegSamDialog(QtWidgets.QDialog):
    """Simple dialog that creates and shows the control panel"""

    def __init__(self, iface, parent=None):
        super().__init__(parent)
        self.iface = iface
        self.control_panel = None

        layout = QtWidgets.QVBoxLayout(self)
        label = QtWidgets.QLabel("GeoOSAM Control Panel")
        label.setStyleSheet("font-size: 14px; font-weight: bold; padding: 10px;")
        layout.addWidget(label)

        show_panel_btn = QtWidgets.QPushButton("Show Control Panel")
        show_panel_btn.clicked.connect(self._show_control_panel)
        layout.addWidget(show_panel_btn)

        close_btn = QtWidgets.QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)

        self.setWindowTitle("GeoOSAM")
        self.resize(250, 120)

    def _show_control_panel(self):
        if not self.control_panel:
            self.control_panel = GeoOSAMControlPanel(self.iface)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.control_panel)
        self.control_panel.show()
        self.control_panel.raise_()
        self.close()